% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tquery.r
\name{find_nodes_functions}
\alias{find_nodes_functions}
\alias{children}
\alias{parents}
\title{Search for parents or children in tquery}
\usage{
children(..., select = NULL, g_id = NULL, save = NA, NOT = F,
  depth = 1)

parents(..., select = NULL, g_id = NULL, save = NA, NOT = F,
  depth = 1)
}
\arguments{
\item{...}{Accepts two types of arguments: name-value pairs for finding nodes (i.e. rows), and functions to look for parents/children of these nodes.

The name in the name-value pairs need to match a column in the data.table, and the value needs to be a vector of the same data type as the column.
Only rows with an exact match to one of the values are found. If multiple name-value pairs are given, they are considered as AND statements. 
If the name is given the suffix __NOT (double underscore), only rows without an exact match are found. (so, lemma__NOT = "fish" look for all rows in which the lemma is not "fish")

To look for parents and children of the nodes that are found, you can use the \link{parents} and \link{children} functions as (named or unnamed) arguments. 
These functions have the same query arguments as tquery, but with some additional arguments.}

\item{select}{An expression to select specific parents/children, which can use any columns in the token data (similar to the subset argument in \link{subset.data.frame}).
However, this has two limitations. Firstly, select should not rely on absolute positions (a logical vector or indices). Secondly, since the expression will only be evaluated
when the query is performed, any names used in the expression that are not columns in the data.table need to be in the environment when the search is performed.
A solution for the second limitation is to explicitly tell tquery to evalute these names immediately, by marking them as .(name). For example, if the name VERBS refers 
to a character vector of verbs, using 'lemma \%in\% .(VERBS)' will replace .(VERBS) with the actual vector.}

\item{g_id}{Find nodes by global id, which is the combination of the doc_id and token_id. Passed as a data.frame or data.table with 2 columns: (1) doc_id and (2) token_id.}

\item{save}{A character vector, specifying the column name under which the selected tokens are returned. 
If NA, the column is not returned.}

\item{NOT}{If TRUE, make having these parents/children a NOT condition.}

\item{depth}{A positive integer, determining how deep parents/children are sought. The default, 1, 
means that only direct parents and children of the node are retrieved. 2 means children and grandchildren, etc.}
}
\value{
Should not be used outside of \link{find_nodes}
}
\description{
Should only be used inside of the \link{tquery} function.
Enables searching for parents or children, either direct (depth = 1) or until a given depth (depth 2 for children and grandchildren, Inf (infinite) for all).
}
\details{
Searching for parents/children within find_nodes works as an AND condition: if it is used, the node must have parents/children.
If select is used to pass an expression, the node must have parents/children for which the expression is TRUE.
The save argument can be used to remember the global token ids (.G_ID) of the parents/children under a given column name.


Having nested queries can be confusing, so we tried to develop the find_nodes function and the accompanying functions in a way
that clearly shows the different levels. As shown in the examples, the idea is that each line is a node, and to look for parents
or children, we put them on the next line with indentation (in RStudio, it should automatically allign correctly when you press enter inside
of the children() or parents() functions).
}
